[{"rendered_body":"\n\u003ch1\u003e\n\u003cspan id=\"awkとは\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#awk%E3%81%A8%E3%81%AF\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eAWKとは\u003c/h1\u003e\n\n\u003cp\u003eAWKはテキスト処理が得意なプログラミング言語です。UNIX/Linux環境であればデフォルトで入っていると思います。\u003c/p\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"awkを学ぶと何がうれしいのか\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#awk%E3%82%92%E5%AD%A6%E3%81%B6%E3%81%A8%E4%BD%95%E3%81%8C%E3%81%86%E3%82%8C%E3%81%97%E3%81%84%E3%81%AE%E3%81%8B\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eAWKを学ぶと何がうれしいのか\u003c/h1\u003e\n\n\u003cp\u003e冷静に考えて、AWKなんて今更まじめに学ぶようなツールではないと感じる人が多い気がします。しかし、2018年でも、特にプログラマにとってAWKがもっとも有用なツールであるという場面があると思います。\u003c/p\u003e\n\n\u003cp\u003eAWKは、コマンドラインから簡単にテキストをフィルターしたり、表示を整えたり、値を集計したりできます。ポイントは「コマンドラインから簡単にテキストを」というところです。GUIから取得するデータや構造化されたファイル（jsonやyaml）を処理するのにAWKを使う必要はないですが、コマンドラインから出力したテキストをその場で処理するのにはすごく便利です。\u003c/p\u003e\n\n\u003cp\u003e例えば、rootが起動しているプロセスのCPU使用率の合計が知りたくなったとします。まず、\u003ccode\u003eps\u003c/code\u003eコマンドで全てのプロセスとそのCPU使用率が取得できます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e ps aux\n\u003cspan class=\"go\"\u003eUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.3 125452  3860 ?        Ss    9月30   0:11 /usr/lib/systemd/systemd --switched-root --system --deserialize 22\nroot         2  0.0  0.0      0     0 ?        S     9月30   0:00 [kthreadd]\nroot         3  0.0  0.0      0     0 ?        S     9月30   0:00 [ksoftirqd/0]\n\n\u003c/span\u003e\u003cspan class=\"c\"\u003e...\n\u003c/span\u003e\u003cspan class=\"go\"\u003e\nsshd     13253  0.0  0.2 112796  2228 ?        S    22:58   0:00 sshd: [net]\nroot     13257  0.0  0.0      0     0 ?        S    22:58   0:00 [kworker/1:3]\nymr      13258  0.0  0.2 158744  2432 ?        D    22:58   0:00 sshd: ymr@pts/0\nymr      13259  0.6  0.2 116240  2740 pts/0    Ss   22:58   0:00 -bash\nroot     13281  0.3  0.6 345904  6408 ?        Sl   22:58   0:00 /usr/sbin/abrt-dbus -t133\nroot     13300  1.0  0.4 158680  4976 ?        Ss   22:58   0:00 sshd: root [priv]\nsshd     13301  0.0  0.2 112796  2228 ?        S    22:58   0:00 sshd: root [net]\nymr      13302  0.0  0.1 155324  1868 pts/0    R+   22:58   0:00 ps aux\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003erootが起動しているプロセスのCPU使用率の合計を出すには、１番目の列が\u003ccode\u003eroot\u003c/code\u003eになっているプロセスだけを抜き出して、３番目の列の値を足し合わせれば良いことがわかります。この処理をどう実行すれば良いでしょうか。\u003ccode\u003eps\u003c/code\u003eの出力を保存して、rubyでテキスト処理をしても良いですし、python/pandasで集計しても便利だと思います。しかし、AWKを使えば以下の１行でやりたいことができます。スクリプトの意味はこの記事を読めばわかるようになりますが、この時点でもなんとなく察することができるのではないでしょうか。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e ps aux | \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'$1 == \"root\" {s += $3} END {print s}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003e1.6\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eAWKはコマンドラインでのテキスト処理や集計に特化したプログラミング言語なので、このようにある一定の状況下ではすごく便利なツールになり得ます。また、文法は非常に簡単で一瞬で覚えられるようなものなので、勉強しておいても損はないでしょう。\u003c/p\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"awkの文法\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#awk%E3%81%AE%E6%96%87%E6%B3%95\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eAWKの文法\u003c/h1\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"プログラムの構造\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%A0%E3%81%AE%E6%A7%8B%E9%80%A0\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eプログラムの構造\u003c/h3\u003e\n\n\u003cp\u003eAWKのプログラムは以下のような構造を取ります。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"awk\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nx\"\u003eawk\u003c/span\u003e \u003cspan class=\"err\"\u003e'\u003c/span\u003e\u003cspan class=\"kr\"\u003eBEGIN\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"err\"\u003eテキストを読む前に行う処理\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"sr\"\u003e/pattern/\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"err\"\u003eテキスト１行に対して行う処理\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e \u003cspan class=\"kr\"\u003eEND\u003c/span\u003e \u003cspan class=\"p\"\u003e{\u003c/span\u003e\u003cspan class=\"err\"\u003eテキストを読み終わった後に行う処理\u003c/span\u003e\u003cspan class=\"p\"\u003e}\u003c/span\u003e\u003cspan class=\"err\"\u003e'\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u003c/span\u003e\u003cspan class=\"nx\"\u003efilename\u003c/span\u003e\u003cspan class=\"o\"\u003e\u0026gt;\u003c/span\u003e\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003e\u0026lt;filename\u0026gt;\u003c/code\u003eには処理したいテキストファイル名を書きます。もちろん、上の\u003ccode\u003eps\u003c/code\u003eコマンドの例のようにコマンドの出力結果をパイプで渡すこともできます。\u003c/p\u003e\n\n\u003cp\u003eまず、\u003ccode\u003e\u0026lt;filename\u0026gt;\u003c/code\u003eで与えられたテキストを読み始める前に\u003ccode\u003eBEGIN\u003c/code\u003eの処理を行います。主に、変数の初期化やヘッダの出力などをすることが多いでしょう。もし特にやりたい処理がない場合は、\u003ccode\u003eBEGIN\u003c/code\u003eは省略可能です。\u003c/p\u003e\n\n\u003cp\u003e続いて、\u003ccode\u003e/pattern/\u003c/code\u003eにマッチするテキストの１行１行に対して行うメインの処理を書きます。ここで、\u003ccode\u003e/pattern/\u003c/code\u003eは正規表現で書くことが多いですが、「3列目の値が**である」など具体的な条件も指定できます。このメインの処理は複数個書くこともできます。\u003ccode\u003e/pattern/\u003c/code\u003eは省略可能で、省略された場合は全ての行に対して処理を行います。テキスト行の特定の列のみを出力したり、特定の列の値の集計をしたりします。\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eEND\u003c/code\u003eに書いた処理は、全てのテキスト行に対する処理が終わった後に走ります。メインの処理で行った集計の結果の出力や、フッタの出力などをします。\u003ccode\u003eBEGIN\u003c/code\u003eと同様に、\u003ccode\u003eEND\u003c/code\u003eも省略可能。\u003c/p\u003e\n\n\u003cp\u003e処理を書くための詳しい文法については次の節で説明しますが、まずは先ほどの\u003ccode\u003eps\u003c/code\u003eコマンドの例の\u003ccode\u003e$ ps aux | awk '$1 == \"root\" {s += $3} END {print s}'\u003c/code\u003eが何をやっているかをAWKプログラムの構造をふまえて考えてみましょう。まず、\u003ccode\u003eBEGIN\u003c/code\u003eは省略されています。\u003ccode\u003e/pattern/\u003c/code\u003eでは１列目（\u003ccode\u003e$1\u003c/code\u003e）の値が\u003ccode\u003eroot\u003c/code\u003eであるという条件を指定しているので、そのような行に対してのみメインの処理を行います。このメイン処理ではCPU使用率の３列目（\u003ccode\u003e$3\u003c/code\u003e）の値を変数\u003ccode\u003es\u003c/code\u003eに足し合わせていきます。最後の\u003ccode\u003eEND\u003c/code\u003eで\u003ccode\u003es\u003c/code\u003eの値を\u003ccode\u003eprint\u003c/code\u003eすることで、\u003ccode\u003eroot\u003c/code\u003eが実行しているプロセスのCPU使用率の合計がわかります。\u003c/p\u003e\n\n\u003cp\u003e以上のように、一般的なプログラミング言語のpythonやrubyとは異なり、AWKでは「１行ずつファイルを読んでいきながら何かの処理をする」という流れがプログラムの構造に最初から組み込まれているので、テキスト処理が簡単に書けます。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"awkスクリプトの文法\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#awk%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E3%81%AE%E6%96%87%E6%B3%95\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eAWKスクリプトの文法\u003c/h3\u003e\n\n\u003cp\u003eAWKプログラムの構造はわかったので、次に具体的な処理を書くための文法について見ていきます。文法と言っても大したものはなく、動的型付けのC言語だと思って適当に書けばだいたいうまくいく気がします。とりあえず、以下の文法を覚えておけば思い描いた処理はだいたい行えるでしょう。関数定義やループ処理などもできるのですが、使用頻度があまり高くない気がするのでこの記事では示さないことにします。\u003c/p\u003e\n\n\u003cp\u003eなお、以下の例ではメインの処理と入力ファイル名が省略できることを利用して\u003ccode\u003eBEGIN\u003c/code\u003eのみ処理を書いています。\u003c/p\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"出力print-printf\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%87%BA%E5%8A%9Bprint-printf\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e出力：\u003ccode\u003eprint, printf\u003c/code\u003e\n\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {print \"hello world\"}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003ehello world\n\n\u003c/span\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {printf \"hello %s\\n\", \"world\"}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003ehello world\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"演算\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E6%BC%94%E7%AE%97\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e演算\u003c/h5\u003e\n\n\u003cp\u003eふつうにいろんな演算ができます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {print 1+2, 5*10, 3/2, 8%3, sin(1), sqrt(3)}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003e3 50 2 1.5\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"変数の利用\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%A4%89%E6%95%B0%E3%81%AE%E5%88%A9%E7%94%A8\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e変数の利用\u003c/h5\u003e\n\n\u003cp\u003e変数の型には数値型と文字列型があります。凝った処理では連想配列を使うこともありますが、とりあえずは気にしなくて良いでしょう。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {a = 4; b = 10; print a + b}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003e14\n\u003c/span\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {s1 = \"hello\"; s2 = \"world\"; printf \"%s %s\\n\", s1, s2}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003ehello world\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"条件分岐if-else\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E6%9D%A1%E4%BB%B6%E5%88%86%E5%B2%90if-else\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e条件分岐：\u003ccode\u003eif-else\u003c/code\u003e\n\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {if (3 \u0026gt; 2) print \"3 \u0026gt; 2\"}'\u003c/span\u003e\n\u003cspan class=\"gp\"\u003e3 \u0026gt;\u003c/span\u003e 2\n\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {s = 13; if (s % 2 == 0) print \"even\"; else print \"odd\"}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003eodd\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"組み込み変数\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E7%B5%84%E3%81%BF%E8%BE%BC%E3%81%BF%E5%A4%89%E6%95%B0\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e組み込み変数\u003c/h3\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"n入力行の中でn番目の値1-2\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#n%E5%85%A5%E5%8A%9B%E8%A1%8C%E3%81%AE%E4%B8%AD%E3%81%A7n%E7%95%AA%E7%9B%AE%E3%81%AE%E5%80%A41-2\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003e$n\u003c/code\u003e：入力行の中で\u003ccode\u003en\u003c/code\u003e番目の値（\u003ccode\u003e$1\u003c/code\u003e, \u003ccode\u003e$2\u003c/code\u003e...）\u003c/h5\u003e\n\n\u003cp\u003eおそらくAWKで一番よく使う変数。一部の列のみの値を取り出したいときに使います。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"a b c d\"\u003c/span\u003e | \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{print $1, $3}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003ea c\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"0入力行の全体\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#0%E5%85%A5%E5%8A%9B%E8%A1%8C%E3%81%AE%E5%85%A8%E4%BD%93\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003e$0\u003c/code\u003e：入力行の全体\u003c/h5\u003e\n\n\u003cp\u003eたまに、行全体をまるまる表示したい時があるのでその際に使います。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"a b c d\"\u003c/span\u003e | \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{print \"alphabet:\", $0}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003ealphabet: a b c d\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"nf入力行に含まれる値の数\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#nf%E5%85%A5%E5%8A%9B%E8%A1%8C%E3%81%AB%E5%90%AB%E3%81%BE%E3%82%8C%E3%82%8B%E5%80%A4%E3%81%AE%E6%95%B0\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003eNF\u003c/code\u003e：入力行に含まれる値の数\u003c/h5\u003e\n\n\u003cp\u003eいま処理している行が何列あるのかを取得できます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"a b c d\"\u003c/span\u003e | \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{print NF}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003e4\n\u003c/span\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"a b c d e f g\"\u003c/span\u003e | \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{print NF}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003e7\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"nr入力行番号\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#nr%E5%85%A5%E5%8A%9B%E8%A1%8C%E7%95%AA%E5%8F%B7\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003eNR\u003c/code\u003e：入力行番号\u003c/h5\u003e\n\n\u003cp\u003eいま処理している行が何行目なのかがわかります。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003ecat\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"no\"\u003eEOF\u003c/span\u003e\u003cspan class=\"sh\"\u003e | awk '{print NR, \u003c/span\u003e\u003cspan class=\"nv\"\u003e$0\u003c/span\u003e\u003cspan class=\"sh\"\u003e}'\n\u003c/span\u003e\u003cspan class=\"gp\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"sh\"\u003ea b c d\n\u003c/span\u003e\u003cspan class=\"gp\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"sh\"\u003ee f g h\n\u003c/span\u003e\u003cspan class=\"gp\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"sh\"\u003ei j k l\n\u003c/span\u003e\u003cspan class=\"gp\"\u003e\u0026gt;\u003c/span\u003e \u003cspan class=\"no\"\u003eEOF\n\u003c/span\u003e\u003cspan class=\"go\"\u003e1 a b c d\n2 e f g h\n3 i j k l\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"fs入力の区切り文字\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#fs%E5%85%A5%E5%8A%9B%E3%81%AE%E5%8C%BA%E5%88%87%E3%82%8A%E6%96%87%E5%AD%97\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003eFS\u003c/code\u003e：入力の区切り文字\u003c/h5\u003e\n\n\u003cp\u003e入力テキストの区切り文字を指定する時に使います。デフォルトでは\u003ccode\u003eFS = \" \"\u003c/code\u003eなのでスペース区切りの入力を処理する時には指定する必要はないのですが、例えば以下のようにカンマ区切りのテキストにAWKを使うときは明示的に区切り文字を指定してあげる必要があります。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003ecat\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"no\"\u003eEOF\u003c/span\u003e\u003cspan class=\"sh\"\u003e | awk 'BEGIN {FS = \",\"} {print \u003c/span\u003e\u003cspan class=\"nv\"\u003e$2\u003c/span\u003e\u003cspan class=\"sh\"\u003e}'\n\u003c/span\u003e\u003cspan class=\"go\"\u003ea,b,c,d\ne,f,g,h\ni,j,k,l\nEOF\nb\nf\nj\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"ofs出力の区切り文字\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#ofs%E5%87%BA%E5%8A%9B%E3%81%AE%E5%8C%BA%E5%88%87%E3%82%8A%E6%96%87%E5%AD%97\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003eOFS\u003c/code\u003e：出力の区切り文字\u003c/h5\u003e\n\n\u003cp\u003e今度は出力するときの区切り文字です。こちらもデフォルトはスペースなので、スペース以外の文字で区切りたいときに明示的に指定してあげます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003ecat\u003c/span\u003e \u003cspan class=\"o\"\u003e\u0026lt;\u0026lt;\u003c/span\u003e\u003cspan class=\"no\"\u003eEOF\u003c/span\u003e\u003cspan class=\"sh\"\u003e | awk 'BEGIN {OFS = \":\"} {print NR, \u003c/span\u003e\u003cspan class=\"nv\"\u003e$2\u003c/span\u003e\u003cspan class=\"sh\"\u003e, \u003c/span\u003e\u003cspan class=\"nv\"\u003e$4\u003c/span\u003e\u003cspan class=\"sh\"\u003e}'\n\u003c/span\u003e\u003cspan class=\"go\"\u003ea b c d\ne f g h\ni j k l\nEOF\n\n1:b:d\n2:f:h\n3:j:l\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eOFS\u003c/code\u003eを使わず、以下のように\u003ccode\u003eprint\u003c/code\u003eの引数に使いたい区切り文字をベタ書きしても良いです。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eecho\u003c/span\u003e \u003cspan class=\"s2\"\u003e\"a b c d\"\u003c/span\u003e | \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{print $1, \"\\t\", $3}'\u003c/span\u003e\n\u003cspan class=\"go\"\u003ea    c\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"便利なスクリプト例\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E4%BE%BF%E5%88%A9%E3%81%AA%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%83%88%E4%BE%8B\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e便利なスクリプト例\u003c/h1\u003e\n\n\u003cp\u003eAWKを使った便利なテキスト処理の例をいくつか挙げたいと思います。ここまでの記事の内容でカバーできているものが多いので、ぜひ考えてみてください。\u003c/p\u003e\n\n\u003cp\u003e処理するテキストファイルの例が決まっていた方がわかりやすいと思うので、以下のテキストを用いることにします。動物のリストで、１列目が種類、2列目が足の本数、3列目が匹数、4列目が生息地（陸/海）を表しています。すなわち、1行目は「犬は足が4本あり、ここに3匹いて、陸上に住む動物である」ということを表しています。ちなみに、今回調べていて知ったこととして、イカの足は10本と思われがちですが、そのうち2本は腕なので足は8本らしいです。よろしくお願いします。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\n\u003cdiv class=\"code-lang\"\u003e\u003cspan class=\"bold\"\u003eanimal.txt\u003c/span\u003e\u003c/div\u003e\n\u003cdiv class=\"highlight\"\u003e\u003cpre\u003einu     4       3       land\nneko    4       2       land\ntako    8       1       sea\nika     8       2       sea\nhito    2       4       land\nkani    10      3       sea\nari     6       7       land\n\u003c/pre\u003e\u003c/div\u003e\n\u003c/div\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"列を抜き出す\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%88%97%E3%82%92%E6%8A%9C%E3%81%8D%E5%87%BA%E3%81%99\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e列を抜き出す\u003c/h3\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"種類だけを表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E7%A8%AE%E9%A1%9E%E3%81%A0%E3%81%91%E3%82%92%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e種類だけを表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{print $1}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003einu\nneko\ntako\nika\nkani\nari\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"種類と生息地を順番を逆にして表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E7%A8%AE%E9%A1%9E%E3%81%A8%E7%94%9F%E6%81%AF%E5%9C%B0%E3%82%92%E9%A0%86%E7%95%AA%E3%82%92%E9%80%86%E3%81%AB%E3%81%97%E3%81%A6%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e種類と生息地を順番を逆にして表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{print $4 \"\\t\" $1}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003eland    inu\nland    neko\nsea     tako\nsea     ika\nsea     kani\nland    ari\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"特定の条件を満たす行を抜き出す\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E7%89%B9%E5%AE%9A%E3%81%AE%E6%9D%A1%E4%BB%B6%E3%82%92%E6%BA%80%E3%81%9F%E3%81%99%E8%A1%8C%E3%82%92%E6%8A%9C%E3%81%8D%E5%87%BA%E3%81%99\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e特定の条件を満たす行を抜き出す\u003c/h3\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"名前にaを含む動物のみ表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%90%8D%E5%89%8D%E3%81%ABa%E3%82%92%E5%90%AB%E3%82%80%E5%8B%95%E7%89%A9%E3%81%AE%E3%81%BF%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e名前に\u003ccode\u003ea\u003c/code\u003eを含む動物のみ表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'$1 ~ /a/'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003etako    8       1       sea\nika     8       2       sea\nkani    10      3       sea\nari     6       7       land\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eこのようにパターンを書くと、１列目の値が正規表現に\u003ccode\u003e/a/\u003c/code\u003eにマッチする列を処理対象とします。ちなみに、\u003ccode\u003eawk '$1 ~ /a/ {print $0}' animals.txt\u003c/code\u003eと書いても良いですが、メインの処理を省略すると入力行をそのまま出力することを利用しています。\u003c/p\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"足の本数が6本以上の動物のみ表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E8%B6%B3%E3%81%AE%E6%9C%AC%E6%95%B0%E3%81%8C6%E6%9C%AC%E4%BB%A5%E4%B8%8A%E3%81%AE%E5%8B%95%E7%89%A9%E3%81%AE%E3%81%BF%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e足の本数が6本以上の動物のみ表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'$2 \u0026gt;= 6'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003etako    8       1       sea\nika     8       2       sea\nkani    10      3       sea\nari     6       7       land\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eこのように、不等号を使ってパターンを書くこともできます。\u003c/p\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"偶数行目のみ表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%81%B6%E6%95%B0%E8%A1%8C%E7%9B%AE%E3%81%AE%E3%81%BF%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e偶数行目のみ表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'NR % 2 == 0'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003eneko    4       2       land\nika     8       2       sea\nari     6       7       land\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e行番号\u003ccode\u003eNR\u003c/code\u003eが偶数であるというパターンを使っています。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"列の値を使った計算集計をする\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%88%97%E3%81%AE%E5%80%A4%E3%82%92%E4%BD%BF%E3%81%A3%E3%81%9F%E8%A8%88%E7%AE%97%E9%9B%86%E8%A8%88%E3%82%92%E3%81%99%E3%82%8B\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e列の値を使った計算/集計をする\u003c/h3\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"全部の動物合わせて何匹いるか表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%85%A8%E9%83%A8%E3%81%AE%E5%8B%95%E7%89%A9%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E4%BD%95%E5%8C%B9%E3%81%84%E3%82%8B%E3%81%8B%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e全部の動物合わせて何匹いるか表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{n += $3} END {print n}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003e18\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e変数\u003ccode\u003en\u003c/code\u003eに各行の匹数（\u003ccode\u003e$3\u003c/code\u003e）を足し合わせていき、最後に\u003ccode\u003eprint\u003c/code\u003eしています。数値型の変数は0に初期化されているので、初期値が0で良いときは明示的に初期化する必要はないです。\u003c/p\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"全部の動物合わせて何本の足があるか表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%85%A8%E9%83%A8%E3%81%AE%E5%8B%95%E7%89%A9%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E4%BD%95%E6%9C%AC%E3%81%AE%E8%B6%B3%E3%81%8C%E3%81%82%E3%82%8B%E3%81%8B%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e全部の動物合わせて何本の足があるか表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{nlegs += ($2 * $3)} END {print nlegs}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003e116\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"陸上の動物合わせて何匹いるか表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E9%99%B8%E4%B8%8A%E3%81%AE%E5%8B%95%E7%89%A9%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E4%BD%95%E5%8C%B9%E3%81%84%E3%82%8B%E3%81%8B%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e陸上の動物合わせて何匹いるか表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'$4 == \"land\" {n += $3} END {print n}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003e12\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003eif\u003c/code\u003e文を使って\u003ccode\u003eawk '{if ($4 == \"land\") n += $3} END {print n}' animals.txt\u003c/code\u003eと書いてもOK。\u003c/p\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"足の本数の最大値を表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E8%B6%B3%E3%81%AE%E6%9C%AC%E6%95%B0%E3%81%AE%E6%9C%80%E5%A4%A7%E5%80%A4%E3%82%92%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e足の本数の最大値を表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{if ($2 \u0026gt; max) max = $2} END {print max}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003e10\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"足の本数に合わせて合否を表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E8%B6%B3%E3%81%AE%E6%9C%AC%E6%95%B0%E3%81%AB%E5%90%88%E3%82%8F%E3%81%9B%E3%81%A6%E5%90%88%E5%90%A6%E3%82%92%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e足の本数に合わせて合否を表示\u003c/h5\u003e\n\n\u003cp\u003e足が8本以上の動物しか認めない人がいた場合。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{if ($2 \u0026gt;= 8) result = \"OK\"; else result = \"NG\"; print $1 \"\\t\" result}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003einu　　　　　　　　　　NG\nneko　　　　　　　　NG\ntako　　　　　　　　OK\nika　　　　　　　　　　OK\nkani　　　　　　　　OK\nari　　　　　　　　　　NG\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"匹数の累積和を表示\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%8C%B9%E6%95%B0%E3%81%AE%E7%B4%AF%E7%A9%8D%E5%92%8C%E3%82%92%E8%A1%A8%E7%A4%BA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e匹数の累積和を表示\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{cumsum += $3; print $1 \"\\t\" cumsum}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003einu　　　　　　　　　　3\nneko　　　　　　　　5\ntako　　　　　　　　6\nika　　　　　　　　　　8\nkani　　　　　　　　11\nari　　　　　　　　　　18\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"aのつく動物とiのつく動物の匹数をそれぞれ計算\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#a%E3%81%AE%E3%81%A4%E3%81%8F%E5%8B%95%E7%89%A9%E3%81%A8i%E3%81%AE%E3%81%A4%E3%81%8F%E5%8B%95%E7%89%A9%E3%81%AE%E5%8C%B9%E6%95%B0%E3%82%92%E3%81%9D%E3%82%8C%E3%81%9E%E3%82%8C%E8%A8%88%E7%AE%97\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003ea\u003c/code\u003eのつく動物と\u003ccode\u003ei\u003c/code\u003eのつく動物の匹数をそれぞれ計算\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'$1 ~ /e/ {num_e += 1} $1 ~ /i/ {num_i += 1} END {printf \"num_e: %d, num_i: %d\\n\", num_e, num_i}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003enum_e: 1, num_i: 4\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eこのように、メインの処理を複数個書くこともできます。\u003c/p\u003e\n\n\u003ch3\u003e\n\u003cspan id=\"フォーマット変更追加\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%83%E3%83%88%E5%A4%89%E6%9B%B4%E8%BF%BD%E5%8A%A0\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eフォーマット変更/追加\u003c/h3\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"ヘッダ追加\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%98%E3%83%83%E3%83%80%E8%BF%BD%E5%8A%A0\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eヘッダ追加\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {print \"kind    numlegs num     habitat\"; print \"-------------------------------\"} {print $0}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003ekind    numlegs num     habitat\n-------------------------------\ninu     4       3       land\nneko    4       2       land\ntako    8       1       sea\nika     8       2       sea\nkani    10      3       sea\nari     6       7       land\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"行番号追加\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E8%A1%8C%E7%95%AA%E5%8F%B7%E8%BF%BD%E5%8A%A0\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e行番号追加\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'{print NR \"\\t\" $0}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003e1   inu     4       3       land\n2   neko    4       2       land\n3   tako    8       1       sea\n4   ika     8       2       sea\n5   kani    10      3       sea\n6   ari     6       7       land\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch5\u003e\n\u003cspan id=\"区切り文字変更\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%8C%BA%E5%88%87%E3%82%8A%E6%96%87%E5%AD%97%E5%A4%89%E6%9B%B4\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e区切り文字変更\u003c/h5\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell-session\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"gp\"\u003e$\u003c/span\u003e \u003cspan class=\"nb\"\u003eawk\u003c/span\u003e \u003cspan class=\"s1\"\u003e'BEGIN {OFS = \",\"} {print $1, $2}'\u003c/span\u003e animals.txt\n\u003cspan class=\"go\"\u003einu,4\nneko,4\ntako,8\nika,8\nkani,10\nari,6\n\u003c/span\u003e\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"まとめ\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eまとめ\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003eAWKはテキスト処理に特化したプログラミング言語\u003c/li\u003e\n\u003cli\u003e特にコマンドラインでテキストファイルを処理/集計したい場合は、短いコードでそこそこ複雑な処理が書けるので便利\u003c/li\u003e\n\u003c/ul\u003e\n","body":"# AWKとは\n\nAWKはテキスト処理が得意なプログラミング言語です。UNIX/Linux環境であればデフォルトで入っていると思います。\n\n# AWKを学ぶと何がうれしいのか\n\n冷静に考えて、AWKなんて今更まじめに学ぶようなツールではないと感じる人が多い気がします。しかし、2018年でも、特にプログラマにとってAWKがもっとも有用なツールであるという場面が\u0010あると思います。\n\nAWKは、コマンドラインから簡単にテキストをフィルターしたり、表示を整えたり、値を集計したりできます。ポイントは「コマンドラインから簡単にテキストを」というところです。GUIから取得するデータや構造化されたファイル（jsonやyaml）を処理するのにAWKを使う必要はないですが、コマンドラインから出力したテキストをその場で処理するのにはすごく便利です。\n\n例えば、rootが起動しているプロセスのCPU使用率の合計が知りたくなったとします。まず、`ps`コマンドで全てのプロセスとそのCPU使用率が取得できます。\n\n```shell-session\n$ ps aux\nUSER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND\nroot         1  0.0  0.3 125452  3860 ?        Ss    9月30   0:11 /usr/lib/systemd/systemd --switched-root --system --deserialize 22\nroot         2  0.0  0.0      0     0 ?        S     9月30   0:00 [kthreadd]\nroot         3  0.0  0.0      0     0 ?        S     9月30   0:00 [ksoftirqd/0]\n\n...\n\nsshd     13253  0.0  0.2 112796  2228 ?        S    22:58   0:00 sshd: [net]\nroot     13257  0.0  0.0      0     0 ?        S    22:58   0:00 [kworker/1:3]\nymr      13258  0.0  0.2 158744  2432 ?        D    22:58   0:00 sshd: ymr@pts/0\nymr      13259  0.6  0.2 116240  2740 pts/0    Ss   22:58   0:00 -bash\nroot     13281  0.3  0.6 345904  6408 ?        Sl   22:58   0:00 /usr/sbin/abrt-dbus -t133\nroot     13300  1.0  0.4 158680  4976 ?        Ss   22:58   0:00 sshd: root [priv]\nsshd     13301  0.0  0.2 112796  2228 ?        S    22:58   0:00 sshd: root [net]\nymr      13302  0.0  0.1 155324  1868 pts/0    R+   22:58   0:00 ps aux\n```\n\nrootが起動しているプロセスのCPU使用率の合計を出すには、１番目の列が`root`になっているプロセスだけを抜き出して、３番目の列の値を足し合わせれば良いことがわかります。この処理をどう実行すれば良いでしょうか。`ps`の出力を保存して、rubyでテキスト処理をしても良いですし、python/pandasで集計しても便利だと思います。しかし、AWKを使えば以下の１行でやりたいことができます。スクリプトの意味はこの記事を読めばわかるようになりますが、この時点でもなんとなく察することができるのではないでしょうか。\n\n```shell-session\n$ ps aux | awk '$1 == \"root\" {s += $3} END {print s}'\n1.6\n```\n\nAWKはコマンドラインでのテキスト処理や集計に特化したプログラミング言語なので、このようにある一定の状況下ではすごく便利なツールになり得ます。また、文法は非常に簡単で一瞬で覚えられるようなものなので、勉強しておいても損はないでしょう。\n\n# AWKの文法\n\n### プログラムの構造\n\nAWKのプログラムは以下のような構造を取ります。\n\n```awk\nawk 'BEGIN {テキストを読む前に行う処理} /pattern/ {テキスト１行に対して行う処理} END {テキストを読み終わった後に行う処理}' \u003cfilename\u003e\n```\n\n`\u003cfilename\u003e`には処理したいテキストファイル名を書きます。もちろん、上の`ps`コマンドの例のようにコマンドの出力結果をパイプで渡すこともできます。\n\nまず、`\u003cfilename\u003e`で与えられたテキストを読み始める前に`BEGIN`の処理を行います。主に、変数の初期化やヘッダの出力などをすることが多いでしょう。もし特にやりたい処理がない場合は、`BEGIN`は省略可能です。\n\n続いて、`/pattern/`にマッチするテキストの１行１行に対して行うメインの処理を書きます。ここで、`/pattern/`は正規表現で書くことが多いですが、「3列目の値が**である」など具体的な条件も指定できます。このメインの処理は複数個書くこともできます。`/pattern/`は省略可能で、省略された場合は全ての行に対して処理を行います。テキスト行の特定の列のみを出力したり、特定の列の値の集計をしたりします。\n\n`END`に書いた処理は、全てのテキスト行に対する処理が終わった後に走ります。メインの処理で行った集計の結果の出力や、フッタの出力などをします。`BEGIN`と同様に、`END`も省略可能。\n\n処理を書くための詳しい文法については次の節で説明しますが、まずは先ほどの`ps`コマンドの例の`$ ps aux | awk '$1 == \"root\" {s += $3} END {print s}'`が何をやっているかをAWKプログラムの構造をふまえて考えてみましょう。まず、`BEGIN`は省略されています。`/pattern/`では１列目（`$1`）の値が`root`であるという条件を指定しているので、そのような行に対してのみメインの処理を行います。このメイン処理ではCPU使用率の３列目（`$3`）の値を変数`s`に足し合わせていきます。最後の`END`で`s`の値を`print`することで、`root`が実行しているプロセスのCPU使用率の合計がわかります。\n\n以上のように、一般的なプログラミング言語のpythonやrubyとは異なり、AWKでは「１行ずつファイルを読んでいきながら何かの処理をする」という流れがプログラムの構造に最初から組み込まれているので、テキスト処理が簡単に書けます。\n\n### AWKスクリプトの文法\n\nAWKプログラムの構造はわかったので、次に具体的な処理を書くための文法について見ていきます。文法と言っても大したものはなく、動的型付けのC言語だと思って適当に書けばだいたいうまくいく気がします。とりあえず、以下の文法を覚えておけば思い描いた処理はだいたい行えるでしょう。関数定義やループ処理などもできるのですが、使用頻度があまり高くない気がするのでこの記事では示さないことにします。\n\nなお、以下の例ではメインの処理と入力ファイル名が省略できることを利用して`BEGIN`のみ処理を書いています。\n\n##### 出力：`print, printf`\n\n```shell-session\n$ awk 'BEGIN {print \"hello world\"}'\nhello world\n\n$ awk 'BEGIN {printf \"hello %s\\n\", \"world\"}'\nhello world\n```\n\n##### 演算\n\nふつうにいろんな演算ができます。\n\n```shell-session\n$ awk 'BEGIN {print 1+2, 5*10, 3/2, 8%3, sin(1), sqrt(3)}'\n3 50 2 1.5\n```\n\n##### 変数の利用\n\n変数の型には数値型と文字列型があります。凝った処理では連想配列を使うこともありますが、とりあえずは気にしなくて良いでしょう。\n\n```shell-session\n$ awk 'BEGIN {a = 4; b = 10; print a + b}'\n14\n$ awk 'BEGIN {s1 = \"hello\"; s2 = \"world\"; printf \"%s %s\\n\", s1, s2}'\nhello world\n```\n\n##### 条件分岐：`if-else`\n\n```shell-session\n$ awk 'BEGIN {if (3 \u003e 2) print \"3 \u003e 2\"}'\n3 \u003e 2\n$ awk 'BEGIN {s = 13; if (s % 2 == 0) print \"even\"; else print \"odd\"}'\nodd\n```\n\n### 組み込み変数\n\n##### `$n`：入力行の中で`n`番目の値（`$1`, `$2`...）\n\nおそらくAWKで一番よく使う変数。一部の列のみの値を取り出したいときに使います。\n\n```shell-session\n$ echo \"a b c d\" | awk '{print $1, $3}'\na c\n```\n\n##### `$0`：入力行の全体\n\nたまに、行全体をまるまる表示したい時があるのでその際に使います。\n\n```shell-session\n$ echo \"a b c d\" | awk '{print \"alphabet:\", $0}'\nalphabet: a b c d\n````\n\n##### `NF`：入力行に含まれる値の数\n\nいま処理している行が何列あるのかを取得できます。\n\n```shell-session\n$ echo \"a b c d\" | awk '{print NF}'\n4\n$ echo \"a b c d e f g\" | awk '{print NF}'\n7\n```\n\n##### `NR`：入力行番号\n\nいま処理している行が何行目なのかがわかります。\n\n```shell-session\n$ cat \u003c\u003cEOF | awk '{print NR, $0}'\n\u003e a b c d\n\u003e e f g h\n\u003e i j k l\n\u003e EOF\n1 a b c d\n2 e f g h\n3 i j k l\n```\n\n##### `FS`：入力の区切り文字\n\n入力テキストの区切り文字を指定する時に使います。デフォルトでは`FS = \" \"`なのでスペース区切りの入力を処理する時には指定する必要はないのですが、例えば以下のようにカンマ区切りのテキストにAWKを使うときは明示的に区切り文字を指定してあげる必要があります。\n\n```shell-session\n$ cat \u003c\u003cEOF | awk 'BEGIN {FS = \",\"} {print $2}'\na,b,c,d\ne,f,g,h\ni,j,k,l\nEOF\nb\nf\nj\n```\n\n##### `OFS`：出力の区切り文字\n\n今度は出力するときの区切り文字です。こちらもデフォルトはスペースなので、スペース以外の文字で区切りたいときに明示的に指定してあげます。\n\n```shell-session\n$ cat \u003c\u003cEOF | awk 'BEGIN {OFS = \":\"} {print NR, $2, $4}'\na b c d\ne f g h\ni j k l\nEOF\n\n1:b:d\n2:f:h\n3:j:l\n```\n\n`OFS`を使わず、以下のように`print`の引数に使いたい区切り文字をベタ書きしても良いです。\n\n```shell-session\n$ echo \"a b c d\" | awk '{print $1, \"\\t\", $3}'\na \t c\n```\n\n# 便利なスクリプト例\n\nAWKを使った便利なテキスト処理の例をいくつか挙げたいと思います。ここまでの記事の内容でカバーできているものが多いので、ぜひ考えてみてください。\n\n処理するテキストファイルの例が決まっていた方がわかりやすいと思うので、以下のテキストを用いることにします。動物のリストで、１列目が種類、2列目が足の本数、3列目が匹数、4列目が生息地（陸/海）を表しています。すなわち、1行目は「犬は足が4本あり、ここに3匹いて、陸上に住む動物である」ということを表しています。ちなみに、今回調べていて知ったこととして、イカの足は10本と思われがちですが、そのうち2本は腕なので足は8本らしいです。よろしくお願いします。\n\n```text:animal.txt\ninu     4       3       land\nneko    4       2       land\ntako    8       1       sea\nika     8       2       sea\nhito    2       4       land\nkani    10      3       sea\nari     6       7       land\n```\n\n### 列を抜き出す\n\n##### 種類だけを表示\n\n```shell-session\n$ awk '{print $1}' animals.txt\ninu\nneko\ntako\nika\nkani\nari\n```\n##### 種類と生息地を順番を逆にして表示\n\n```shell-session\n$ awk '{print $4 \"\\t\" $1}' animals.txt\nland    inu\nland    neko\nsea     tako\nsea     ika\nsea     kani\nland    ari\n```\n\n### 特定の条件を満たす行を抜き出す\n\n##### 名前に`a`を含む動物のみ表示\n\n```shell-session\n$ awk '$1 ~ /a/' animals.txt\ntako    8       1       sea\nika     8       2       sea\nkani    10      3       sea\nari     6       7       land\n```\n\nこのようにパターンを書くと、１列目の値が正規表現に`/a/`にマッチする列を処理対象とします。ちなみに、`awk '$1 ~ /a/ {print $0}' animals.txt`と書いても良いですが、メインの処理を省略すると入力行をそのまま出力することを利用しています。\n\n##### 足の本数が6本以上の動物のみ表示\n\n```shell-session\n$ awk '$2 \u003e= 6' animals.txt\ntako    8       1       sea\nika     8       2       sea\nkani    10      3       sea\nari     6       7       land\n```\n\nこのように、不等号を使ってパターンを書くこともできます。\n\n##### 偶数行目のみ表示\n\n```shell-session\n$ awk 'NR % 2 == 0' animals.txt\nneko    4       2       land\nika     8       2       sea\nari     6       7       land\n```\n\n行番号`NR`が偶数であるというパターンを使っています。\n\n### 列の値を使った計算/集計をする\n\n##### 全部の動物合わせて何匹いるか表示\n\n```shell-session\n$ awk '{n += $3} END {print n}' animals.txt\n18\n```\n\n変数`n`に各行の匹数（`$3`）を足し合わせていき、最後に`print`しています。数値型の変数は0に初期化されているので、初期値が0で良いときは明示的に初期化する必要はないです。\n\n##### 全部の動物合わせて何本の足があるか表示\n\n```shell-session\n$ awk '{nlegs += ($2 * $3)} END {print nlegs}' animals.txt\n116\n```\n\n##### 陸上の動物合わせて何匹いるか表示\n\n```shell-session\n$ awk '$4 == \"land\" {n += $3} END {print n}' animals.txt\n12\n```\n\n`if`文を使って`awk '{if ($4 == \"land\") n += $3} END {print n}' animals.txt`と書いてもOK。\n\n##### 足の本数の最大値を表示\n\n```shell-session\n$ awk '{if ($2 \u003e max) max = $2} END {print max}' animals.txt\n10\n```\n\n##### 足の本数に合わせて合否を表示\n\n足が8本以上の動物しか認めない人がいた場合。\n\n```shell-session\n$ awk '{if ($2 \u003e= 8) result = \"OK\"; else result = \"NG\"; print $1 \"\\t\" result}' animals.txt\ninu　　　　　　　　　　NG\nneko　　　　　　　　NG\ntako　　　　　　　　OK\nika　　　　　　　　　　OK\nkani　　　　　　　　OK\nari　　　　　　　　　　NG\n```\n\n##### 匹数の累積和を表示\n\n```shell-session\n$ awk '{cumsum += $3; print $1 \"\\t\" cumsum}' animals.txt\ninu　　　　　　　　　　3\nneko　　　　　　　　5\ntako　　　　　　　　6\nika　　　　　　　　　　8\nkani　　　　　　　　11\nari　　　　　　　　　　18\n```\n\n##### `a`のつく動物と`i`のつく動物の匹数をそれぞれ計算\n\n```shell-session\n$ awk '$1 ~ /e/ {num_e += 1} $1 ~ /i/ {num_i += 1} END {printf \"num_e: %d, num_i: %d\\n\", num_e, num_i}' animals.txt\nnum_e: 1, num_i: 4\n```\n\nこのように、メインの処理を複数個書くこともできます。\n\n### フォーマット変更/追加\n\n##### ヘッダ追加\n\n```shell-session\n$ awk 'BEGIN {print \"kind    numlegs num     habitat\"; print \"-------------------------------\"} {print $0}' animals.txt\nkind    numlegs num     habitat\n-------------------------------\ninu     4       3       land\nneko    4       2       land\ntako    8       1       sea\nika     8       2       sea\nkani    10      3       sea\nari     6       7       land\n```\n\n##### 行番号追加\n\n```shell-session\n$ awk '{print NR \"\\t\" $0}' animals.txt\n1\tinu     4       3       land\n2\tneko    4       2       land\n3\ttako    8       1       sea\n4\tika     8       2       sea\n5\tkani    10      3       sea\n6\tari     6       7       land\n```\n\n##### 区切り文字変更\n\n```shell-session\n$ awk 'BEGIN {OFS = \",\"} {print $1, $2}' animals.txt\ninu,4\nneko,4\ntako,8\nika,8\nkani,10\nari,6\n```\n\n# まとめ\n\n- AWKはテキスト処理に特化したプログラミング言語\n- 特にコマンドラインでテキストファイルを処理/集計したい場合は、短いコードでそこそこ複雑な処理が書けるので便利\n","coediting":false,"comments_count":0,"created_at":"2018-10-10T01:27:55+09:00","group":null,"id":"02ddff566231bdb04a75","likes_count":6,"private":false,"reactions_count":0,"tags":[{"name":"Linux","versions":[]},{"name":"awk","versions":[]},{"name":"コマンド","versions":[]},{"name":"テキストマイニング","versions":[]}],"title":"テキスト処理にたまに便利なAWK入門","updated_at":"2018-10-10T01:27:55+09:00","url":"https://qiita.com/muiscript/items/02ddff566231bdb04a75","user":{"description":"Go / Typescript / Ruby / shell script","facebook_id":"","followees_count":5,"followers_count":12,"github_login_name":"muiscript","id":"muiscript","items_count":14,"linkedin_id":"","location":"","name":"","organization":"","permanent_id":159260,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/159260/profile-images/1539056316","team_only":false,"twitter_screen_name":null,"website_url":""},"page_views_count":null},{"rendered_body":"\n\u003ch1\u003e\n\u003cspan id=\"概要\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E6%A6%82%E8%A6%81\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e概要\u003c/h1\u003e\n\n\u003cp\u003eサーバの応答が遅くなるなど計算機のパフォーマンスに問題が生じたとき、原因としてCPU・メモリ・IO・ネットワークなど色々な原因が考えられます。原因を特定するために、それぞれのリソースの状況を見ていき、例えば「CPU使用率が100%近い値になっていないか」「メモリが足りなくなってスワッピングが頻繁に起きていないか」など考えられるものを検証していく必要があります。\u003c/p\u003e\n\n\u003cp\u003e計算機の状況を知るためのコマンドには\u003ccode\u003evmstat\u003c/code\u003eや\u003ccode\u003eiostat\u003c/code\u003e、\u003ccode\u003etop\u003c/code\u003eや\u003ccode\u003eps\u003c/code\u003eなどいろいろあると思いますが、その中でも\u003ccode\u003esar\u003c/code\u003eは様々なリソースについて過去に遡って見ることができるため、大まかな原因特定に非常に役立つので、使い方についてまとめておきます。\u003c/p\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"sarコマンドの基本的な使い方\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#sar%E3%82%B3%E3%83%9E%E3%83%B3%E3%83%89%E3%81%AE%E5%9F%BA%E6%9C%AC%E7%9A%84%E3%81%AA%E4%BD%BF%E3%81%84%E6%96%B9\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003esar\u003c/code\u003eコマンドの基本的な使い方\u003c/h1\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"オプション引数\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3%E5%BC%95%E6%95%B0\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eオプション/引数\u003c/h4\u003e\n\n\u003cp\u003e\u003ccode\u003esar\u003c/code\u003eを使えば、CPU・メモリなど計算機のパフォーマンスに関わる様々なリソースの情報を得ることができます。引数やオプションの基本的な構造は以下の通り。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"text\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003esar [...options] \u0026lt;interval\u0026gt; \u0026lt;count\u0026gt; -f \u0026lt;saXX file\u0026gt;\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003eここで、\u003ccode\u003e[...options]\u003c/code\u003eには、「どのCPUリソースについて見たいか」を指定します。例えば、\u003ccode\u003e-r\u003c/code\u003eというオプションならばメモリの情報を、\u003ccode\u003e-u\u003c/code\u003eならばCPUの情報を見ることができるという感じです。一方で、そのあとの\u003ccode\u003e\u0026lt;interval\u0026gt;\u003c/code\u003eや\u003ccode\u003e\u0026lt;count\u0026gt;\u003c/code\u003eなどの引数は、あるリソースについて、「いつの情報をどのような間隔」で見るのかを指定します。\u003c/p\u003e\n\n\u003cp\u003eこの記事では、どういうオプションを指定した時にどのような情報が得られるのかを主にまとめますが、その前に「いつの情報を見るか」を指定する引数について簡単に見ておきます。以下の例では、一貫して\u003ccode\u003e-r\u003c/code\u003eオプションでメモリの情報を見ることにします。\u003c/p\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"引数なし\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%BC%95%E6%95%B0%E3%81%AA%E3%81%97\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e引数なし\u003c/h4\u003e\n\n\u003cp\u003eオプション以外の引数を指定せず（例えば\u003ccode\u003esar -r\u003c/code\u003e）とコマンドを打つと、システムが自動で一定間隔で取ってくれているその日のリソースの情報が出力されます。間隔は自分で指定することもできますが、デフォルトでは10分になっていることが多いと思います。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-r\u003c/span\u003e\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n12:00:01 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n12:10:01 AM    416372    599052     59.00     24524    434468    276164      8.87    371660    157708         0\n12:20:02 AM    416544    598880     58.98     24568    434480    276164      8.87    371644    157756         0\n12:30:01 AM    414176    601248     59.21     24668    434540    303108      9.74    373848    157596         0\n12:40:01 AM    416288    599136     59.00     24716    434536    275948      8.87    371800    157632         0\n12:50:01 AM    415956    599468     59.04     24780    434540    275948      8.87    371860    157688         0\n01:00:01 AM    415772    599652     59.05     24984    434624    276052      8.87    373380    156556         4\n01:10:01 AM    415680    599744     59.06     25052    434628    276052      8.87    373416    156600         0\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"saxxファイルの指定\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#saxx%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AE%E6%8C%87%E5%AE%9A\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003esaXX\u003c/code\u003eファイルの指定\u003c/h4\u003e\n\n\u003cp\u003e引数なしだと当日の情報しか見れないが、過去に遡って昨日以前の情報を見たいときがあります。実は、システムが\u003ccode\u003esar\u003c/code\u003eコマンドで自動で取得された情報は、一定期間はファイルとして特定のディレクトリに保存されています。例えば、CentOS7だと\u003ccode\u003e/var/log/sa\u003c/code\u003e以下にありました。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003e\u003cspan class=\"nb\"\u003els\u003c/span\u003e /var/log/sa\nsa01  sa12  sa15  sa18  sa21  sa24  sa27  sa30   sar13  sar16  sar19  sar22  sar25  sar28\nsa10  sa13  sa16  sa19  sa22  sa25  sa28  sar11  sar14  sar17  sar20  sar23  sar26  sar29\nsa11  sa14  sa17  sa20  sa23  sa26  sa29  sar12  sar15  sar18  sar21  sar24  sar27  sar30\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003esar\u003c/code\u003eの後の数字が日付を表していて、例えば直近の26日の情報は\u003ccode\u003esa26\u003c/code\u003eファイルに保存されています。このファイルの名前を\u003ccode\u003e-f\u003c/code\u003eオプションの後に指定してあげると、その日の\u003ccode\u003esar\u003c/code\u003eの結果を見ることができます。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-r\u003c/span\u003e \u003cspan class=\"nt\"\u003e-f\u003c/span\u003e /var/log/sa/sa26\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   09/26/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n12:00:01 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n12:10:01 AM    359760    655664     64.57     91228    407732    336816     10.82    385472    190128         4\n12:20:02 AM    359512    655912     64.59     91256    407740    336816     10.82    385492    190144         0\n12:30:01 AM    359800    655624     64.57     91280    407752    336816     10.82    385484    190132         0\n12:40:01 AM    359736    655688     64.57     91320    407768    336816     10.82    385516    190152        32\n12:50:01 AM    359076    656348     64.64     91568    408048    336816     10.82    385916    190292         0\n01:00:01 AM    359360    656064     64.61     91580    408040    336816     10.82    385988    190288         0\n01:10:01 AM    359132    656292     64.63     91604    408064    336816     10.82    386040    190284         0\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"intervalcountの指定\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#intervalcount%E3%81%AE%E6%8C%87%E5%AE%9A\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e\u003ccode\u003einterval\u003c/code\u003e/\u003ccode\u003ecount\u003c/code\u003eの指定\u003c/h4\u003e\n\n\u003cp\u003eここまでで、過去に遡って計算機のリソース情報が見れることがわかりました。しかし、リアルタイムでもっと細かく計算機の状況が見たいことがあるでしょう。そのときは、情報を取得する間隔（\u003ccode\u003einterval\u003c/code\u003e）と回数（\u003ccode\u003ecount\u003c/code\u003e）を指定します。例えば、以下は１秒おきに３回情報を取得する例です。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-r\u003c/span\u003e 1 3\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n11:07:45 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n11:07:46 PM    351688    663736     65.37     50352    456532    287176      9.23    394068    182800         0\n11:07:47 PM    351688    663736     65.37     50352    456532    287176      9.23    394108    182800         0\n11:07:48 PM    351704    663720     65.36     50352    456532    287176      9.23    394120    182800         0\nAverage:       351693    663731     65.36     50352    456532    287176      9.23    394099    182800         0\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cp\u003e\u003ccode\u003ecount\u003c/code\u003eを引数として与えない場合は指定した\u003ccode\u003einterval\u003c/code\u003eで永遠に情報を取得し続けることになります。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-r\u003c/span\u003e 2\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n11:10:56 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n11:10:58 PM    351584    663840     65.38     50368    456536    287232      9.23    394124    182816         0\n11:11:00 PM    351584    663840     65.38     50368    456536    287232      9.23    394124    182816         0\n11:11:02 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n11:11:04 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n11:11:06 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n11:11:08 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n11:11:10 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"見るリソースを指定するオプション\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E8%A6%8B%E3%82%8B%E3%83%AA%E3%82%BD%E3%83%BC%E3%82%B9%E3%82%92%E6%8C%87%E5%AE%9A%E3%81%99%E3%82%8B%E3%82%AA%E3%83%97%E3%82%B7%E3%83%A7%E3%83%B3\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e見るリソースを指定するオプション\u003c/h1\u003e\n\n\u003cp\u003eここまでで、\u003ccode\u003esar\u003c/code\u003eコマンドを使って「いつの」情報を見るかの指定方法についてはだいたいわかったので、次に「どの」情報を見るかの指定方法を見ていきます。最初に述べたように、どのリソースの情報を見るかはオプションで指定します。オプションは大量にある（\u003ccode\u003eman\u003c/code\u003eで見てくれ）のですが、その中でも利用頻度が高そうなオプションについて示します。また、各オプションに対して出力される情報の中でも特に有用と思われるものについてのみ内容を示しています。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"cpu\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#cpu\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eCPU\u003c/h2\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"cpu使用率sar--p-all\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#cpu%E4%BD%BF%E7%94%A8%E7%8E%87sar--p-all\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eCPU使用率（\u003ccode\u003esar -P ALL\u003c/code\u003e）\u003c/h4\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-P\u003c/span\u003e ALL 1\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n01:17:35 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle\n01:17:36 AM     all      0.00      0.00      0.00      0.00      0.00    100.00\n01:17:36 AM       0      0.00      0.00      0.00      0.00      0.00    100.00\n01:17:36 AM       1      0.00      0.00      0.00      0.00      0.00    100.00\n\n01:17:36 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle\n01:17:37 AM     all      0.00      0.00      0.00      0.00      0.00    100.00\n01:17:37 AM       0      0.00      0.00      0.00      0.00      0.00    100.00\n01:17:37 AM       1      0.00      0.00      0.00      0.00      0.00    100.00\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003e%user\u003c/code\u003e：CPUがユーザモードにあった時間の割合\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003e%system\u003c/code\u003e：CPUがカーネルモードにあった時間の割合\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003e%iowait\u003c/code\u003e：CPUがIO待ちをしていた時間の割合\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003e%idle\u003c/code\u003e：CPUがアイドル状態にあった時間の割合\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eマルチコアの場合、上記の結果ようにCPUごとの使用率が見られます。当然ですが、全てのカラムの値を足すと100%になります。\u003ccode\u003e%idle\u003c/code\u003eの値が小さいとCPUの使用率が高いということになので、CPUがパフォーマンスのボトルネックになっている可能性があります。\u003c/p\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"ランキューload-averagesar--q\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%A9%E3%83%B3%E3%82%AD%E3%83%A5%E3%83%BCload-averagesar--q\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eランキュー/load average（\u003ccode\u003esar -q\u003c/code\u003e）\u003c/h4\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-q\u003c/span\u003e 1\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n01:17:09 AM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked\n01:17:10 AM         1       102      0.00      0.01      0.03         0\n01:17:11 AM         1       102      0.00      0.01      0.03         0\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003erunq-sz\u003c/code\u003e：ランキューにあるタスク数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003eldavg-\u0026lt;n\u0026gt;\u003c/code\u003e：最近n分間のロードアベレージ\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eランキューにあるタスク数は、「CPUが現在同時に実行しているタスク数」を表しています。一般に、ランキューにあるタスク数がCPUの数を超えると、CPUの数が足りておらずパフォーマンスが落ちている可能性があると言われています。ランキューのタスク数は計算機のパフォーマンスがおかしい時に必ず見るべき重要な指標です。ロードアベレージはランキューのタスク数の時間平均で、こちらも同様に重要です。過去１分間、５分間、１５分間の値が表示されているので、大まかに、負荷が上がってきているのか落ち着いてきているのか把握することができます。\u003c/p\u003e\n\n\u003cp\u003eランキュー/ロードアベレージについてのもっとちゃんとした説明は世の中にたくさんあると思いますが、自分は\u003ca href=\"https://www.amazon.co.jp/24%E6%99%82%E9%96%93365%E6%97%A5-%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E3%82%92%E6%94%AF%E3%81%88%E3%82%8B%E6%8A%80%E8%A1%93-%E2%80%BE%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%A9%E3%83%93%E3%83%AA%E3%83%86%E3%82%A3%E3%80%81%E3%83%8F%E3%82%A4%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%80%81%E7%9C%81%E5%8A%9B%E9%81%8B%E7%94%A8-PRESS-plus%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/dp/4774135666\" rel=\"nofollow noopener\" target=\"_blank\"\u003eサーバ/インフラを支える技術\u003c/a\u003eの4.1節が非常にわかりやすかったのでおすすめです。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"メモリ\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%A1%E3%83%A2%E3%83%AA\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eメモリ\u003c/h2\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"メモリ使用率sar--r\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%A1%E3%83%A2%E3%83%AA%E4%BD%BF%E7%94%A8%E7%8E%87sar--r\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eメモリ使用率（\u003ccode\u003esar -r\u003c/code\u003e）\u003c/h4\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-r\u003c/span\u003e 1\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n01:16:48 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n01:16:49 AM    416672    598752     58.97     25092    434648    274480      8.82    373028    156644         0\n01:16:50 AM    416672    598752     58.97     25092    434648    274480      8.82    373028    156644         0\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003ekbmemfree\u003c/code\u003e：空きメモリのkB数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003ekbmemused\u003c/code\u003e：使用中メモリのkB数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003e%memused\u003c/code\u003e：メモリ使用率\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003ekbbuffers\u003c/code\u003e：バッファとして使われているメモリのkB数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003ekbcached\u003c/code\u003e：ページキャッシュとして使われているメモリのkB数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003eメモリが足りなくなると、メモリの一部をストレージに退避させるスワッピングが発生しパフォーマンスが大きく劣化することがあるので注意。ただし、\u003ccode\u003ekbbuffers\u003c/code\u003eと\u003ccode\u003ekbcached\u003c/code\u003eはカーネルがいつでも開放することができるキャッシュなので、たとえメモリ使用率が高かったとしても、この２つの値が大きい場合には問題にはなりません。ページキャッシュやスワップについてのわかりやすい記事として、例えば \u003ca href=\"https://qiita.com/kunihirotanaka/items/70d43d48757aea79de2d\" id=\"reference-7f52ab92354d741ddb85\"\u003eいまさら聞けないLinuxとメモリの基礎＆vmstatの詳しい使い方\u003c/a\u003e を読むと良いでしょう。\u003c/p\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"スワッピングsar--ssar--w\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%82%B9%E3%83%AF%E3%83%83%E3%83%94%E3%83%B3%E3%82%B0sar--ssar--w\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eスワッピング（\u003ccode\u003esar -S\u003c/code\u003e、\u003ccode\u003esar -W\u003c/code\u003e）\u003c/h4\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-S\u003c/span\u003e 1\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n01:16:32 AM kbswpfree kbswpused  %swpused  kbswpcad   %swpcad\n01:16:33 AM   2097148         0      0.00         0      0.00\n01:16:34 AM   2097148         0      0.00         0      0.00\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003ekbswpfree\u003c/code\u003e：空いているスワップ領域のkB数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003ekbswpused\u003c/code\u003e：使用中のスワップ領域のkB数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003e%swpused\u003c/code\u003e：スワップ領域の使用率\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ccode\u003ekbswapused\u003c/code\u003eが0よりも大きい値ならばスワッピングが発生していることになります。\u003c/p\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-W\u003c/span\u003e 1\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n01:16:14 AM  pswpin/s pswpout/s\n01:16:15 AM      0.00      0.00\n01:16:16 AM      0.00      0.00\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003epswpin/s\u003c/code\u003e：１秒間あたりのスワップインされたページ数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003epswpout/s\u003c/code\u003e：１秒間あたりのスワップアウトされたページ数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e特に、スワップアウトが連続で起きている場合はパフォーマンスに影響を与えている可能性が高いです。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"ディスクio\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AFio\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eディスクIO\u003c/h2\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"読み込み書き込み量sar--d--p\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E8%AA%AD%E3%81%BF%E8%BE%BC%E3%81%BF%E6%9B%B8%E3%81%8D%E8%BE%BC%E3%81%BF%E9%87%8Fsar--d--p\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e読み込み/書き込み量（\u003ccode\u003esar -d -p\u003c/code\u003e）\u003c/h4\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-d\u003c/span\u003e \u003cspan class=\"nt\"\u003e-p\u003c/span\u003e 1\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n01:15:54 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util\n01:15:55 AM       vda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n01:15:55 AM       sr1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n\n01:15:55 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util\n01:15:56 AM       vda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n01:15:56 AM       sr1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003etps\u003c/code\u003e：１秒間あたりのI/O転送回数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003etd_sec/s\u003c/code\u003e：１秒間あたりに読み込みを行ったセクター数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003ewr_sec/s\u003c/code\u003e：１秒間あたりに書き込みを行ったセクター数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003eawait\u003c/code\u003e：I/O応答時間の平均\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003e%util\u003c/code\u003e：ディスクの使用率（I/O処理をしていてビジーだった時間の割合）\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ccode\u003e%util\u003c/code\u003eの値が大きい場合はIOがボトルネックになっている可能性があります。また、\u003ccode\u003eawait\u003c/code\u003eはアプリケーションのパフォーマンスに直接的に影響する値なので重要です。\u003c/p\u003e\n\n\u003ch2\u003e\n\u003cspan id=\"ネットワーク\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%83%8D%E3%83%83%E3%83%88%E3%83%AF%E3%83%BC%E3%82%AF\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eネットワーク\u003c/h2\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"受信送信パケット数sar--n-dev\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E5%8F%97%E4%BF%A1%E9%80%81%E4%BF%A1%E3%83%91%E3%82%B1%E3%83%83%E3%83%88%E6%95%B0sar--n-dev\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003e受信/送信パケット数（\u003ccode\u003esar -n DEV\u003c/code\u003e）\u003c/h4\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e DEV 1\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n01:15:29 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s\n01:15:30 AM      eth0     19.00      0.00      2.27      0.00      0.00      0.00      0.00\n01:15:30 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n\n01:15:30 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s\n01:15:31 AM      eth0     23.00      1.00      2.39      0.18      0.00      0.00      0.00\n01:15:31 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003erxpck/s\u003c/code\u003e：１秒間あたりの受信パケット数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003etxpck/s\u003c/code\u003e：１秒間あたりの送信パケット数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003erxkB/s\u003c/code\u003e：１秒間あたりの受信kB数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003etxkB/s\u003c/code\u003e：１秒間あたりの送信kB数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch4\u003e\n\u003cspan id=\"tcp接続数sar--n-tcp\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#tcp%E6%8E%A5%E7%B6%9A%E6%95%B0sar--n-tcp\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eTCP接続数（\u003ccode\u003esar -n TCP\u003c/code\u003e）\u003c/h4\u003e\n\n\u003cdiv class=\"code-frame\" data-lang=\"shell\"\u003e\u003cdiv class=\"highlight\"\u003e\u003cpre\u003e\u003cspan class=\"nv\"\u003e$ \u003c/span\u003esar \u003cspan class=\"nt\"\u003e-n\u003c/span\u003e TCP 1\nLinux 3.10.0-862.2.3.el7.x86_64 \u003cspan class=\"o\"\u003e(\u003c/span\u003e118-27-1-88\u003cspan class=\"o\"\u003e)\u003c/span\u003e   10/01/2018  _x86_64_    \u003cspan class=\"o\"\u003e(\u003c/span\u003e2 CPU\u003cspan class=\"o\"\u003e)\u003c/span\u003e\n\n01:14:59 AM  active/s passive/s    iseg/s    oseg/s\n01:15:00 AM      0.00      0.00      2.00      0.00\n01:15:01 AM      0.00      0.00      1.00      1.00\n...\n\u003c/pre\u003e\u003c/div\u003e\u003c/div\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003eactive/s\u003c/code\u003e：１秒間あたりのアクティブなTCP新規接続数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003epassive/s\u003c/code\u003e：１秒間あたりのパッシブなTCP新規接続数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003eiseg/s\u003c/code\u003e：１秒間あたりの受信セグメント数\u003c/li\u003e\n\u003cli\u003e\n\u003ccode\u003eoseg/s\u003c/code\u003e：１秒間あたりの送信セグメント数\u003c/li\u003e\n\u003c/ul\u003e\n\n\u003ch1\u003e\n\u003cspan id=\"まとめ\" class=\"fragment\"\u003e\u003c/span\u003e\u003ca href=\"#%E3%81%BE%E3%81%A8%E3%82%81\"\u003e\u003ci class=\"fa fa-link\"\u003e\u003c/i\u003e\u003c/a\u003eまとめ\u003c/h1\u003e\n\n\u003cul\u003e\n\u003cli\u003e\n\u003ccode\u003esar\u003c/code\u003eを使うと、オプションを指定することによってCPUやメモリ、IOやネットワークなど計算機のパフォーマンスに関わる様々なリソースの情報を見ることができる。\u003c/li\u003e\n\u003cli\u003e自動で定期的に\u003ccode\u003esar\u003c/code\u003eの情報が取得されているので、過去に遡って計算機の状況を確認することができる。一方で、リアルタイムで自由に間隔を指定して情報を取得することもできる\u003c/li\u003e\n\u003c/ul\u003e\n","body":"# 概要\n\nサーバの応答が遅くなるなど計算機のパフォーマンスに問題が生じたとき、原因としてCPU・メモリ・IO・ネットワークなど色々な原因が考えられます。原因を特定するために、それぞれのリソースの状況を見ていき、例えば「CPU使用率が100%近い値になっていないか」「メモリが足りなくなってスワッピングが頻繁に起きていないか」など考えられるものを検証していく必要があります。\n\n計算機の状況を知るためのコマンドには`vmstat`や`iostat`、`top`や`ps`などいろいろあると思いますが、その中でも`sar`は様々なリソースについて過去に遡って見ることができるため、大まかな原因特定に非常に役立つので、使い方についてまとめておきます。\n\n# `sar`コマンドの基本的な使い方\n\n#### オプション/引数\n\n`sar`を使えば、CPU・メモリなど計算機のパフォーマンスに関わる様々なリソースの情報を得ることができます。引数やオプションの基本的な構造は以下の通り。\n\n```\nsar [...options] \u003cinterval\u003e \u003ccount\u003e -f \u003csaXX file\u003e\n```\n\nここで、`[...options]`には、「どのCPUリソースについて見たいか」を指定します。例えば、`-r`というオプションならばメモリの情報を、`-u`ならばCPUの情報を見ることができるという感じです。一方で、そのあとの`\u003cinterval\u003e`や`\u003ccount\u003e`などの引数は、あるリソースについて、「いつの情報をどのような間隔」で見るのかを指定します。\n\nこの記事では、どういうオプションを指定した時にどのような情報が得られるのかを主にまとめますが、その前に「いつの情報を見るか」を指定する引数について簡単に見ておきます。以下の例では、一貫して`-r`オプションでメモリの情報を見ることにします。\n\n#### 引数なし\n\nオプション以外の引数を指定せず（例えば`sar -r`）とコマンドを打つと、システムが自動で一定間隔で取ってくれているその日のリソースの情報が出力されます。間隔は自分で指定することもできますが、デフォルトでは10分になっていることが多いと思います。\n\n```shell\n$ sar -r\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n12:00:01 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n12:10:01 AM    416372    599052     59.00     24524    434468    276164      8.87    371660    157708         0\n12:20:02 AM    416544    598880     58.98     24568    434480    276164      8.87    371644    157756         0\n12:30:01 AM    414176    601248     59.21     24668    434540    303108      9.74    373848    157596         0\n12:40:01 AM    416288    599136     59.00     24716    434536    275948      8.87    371800    157632         0\n12:50:01 AM    415956    599468     59.04     24780    434540    275948      8.87    371860    157688         0\n01:00:01 AM    415772    599652     59.05     24984    434624    276052      8.87    373380    156556         4\n01:10:01 AM    415680    599744     59.06     25052    434628    276052      8.87    373416    156600         0\n...\n```\n\n#### `saXX`ファイルの指定\n\n引数なしだと当日の情報しか見れないが、過去に遡って昨日以前の情報を見たいときがあります。実は、システムが`sar`コマンドで自動で取得された情報は、一定期間はファイルとして特定のディレクトリに保存されています。例えば、CentOS7だと`/var/log/sa`以下にありました。\n\n```shell\n$ ls /var/log/sa\nsa01  sa12  sa15  sa18  sa21  sa24  sa27  sa30   sar13  sar16  sar19  sar22  sar25  sar28\nsa10  sa13  sa16  sa19  sa22  sa25  sa28  sar11  sar14  sar17  sar20  sar23  sar26  sar29\nsa11  sa14  sa17  sa20  sa23  sa26  sa29  sar12  sar15  sar18  sar21  sar24  sar27  sar30\n```\n\n`sar`の後の数字が日付を表していて、例えば直近の26日の情報は`sa26`ファイルに保存されています。このファイルの名前を`-f`オプションの後に指定してあげると、その日の`sar`の結果を見ることができます。\n\n```shell\n$ sar -r -f /var/log/sa/sa26\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t09/26/2018 \t_x86_64_\t(2 CPU)\n\n12:00:01 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n12:10:01 AM    359760    655664     64.57     91228    407732    336816     10.82    385472    190128         4\n12:20:02 AM    359512    655912     64.59     91256    407740    336816     10.82    385492    190144         0\n12:30:01 AM    359800    655624     64.57     91280    407752    336816     10.82    385484    190132         0\n12:40:01 AM    359736    655688     64.57     91320    407768    336816     10.82    385516    190152        32\n12:50:01 AM    359076    656348     64.64     91568    408048    336816     10.82    385916    190292         0\n01:00:01 AM    359360    656064     64.61     91580    408040    336816     10.82    385988    190288         0\n01:10:01 AM    359132    656292     64.63     91604    408064    336816     10.82    386040    190284         0\n...\n```\n\n#### `interval`/`count`の指定\n\nここまでで、過去に遡って計算機のリソース情報が見れることがわかりました。しかし、リアルタイムでもっと細かく計算機の状況が見たいことがあるでしょう。そのときは、情報を取得する間隔（`interval`）と回数（`count`）を指定します。例えば、以下は１秒おきに３回情報を取得する例です。\n\n```shell\n$ sar -r 1 3\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n11:07:45 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n11:07:46 PM    351688    663736     65.37     50352    456532    287176      9.23    394068    182800         0\n11:07:47 PM    351688    663736     65.37     50352    456532    287176      9.23    394108    182800         0\n11:07:48 PM    351704    663720     65.36     50352    456532    287176      9.23    394120    182800         0\nAverage:       351693    663731     65.36     50352    456532    287176      9.23    394099    182800         0\n```\n\n`count`を引数として与えない場合は指定した`interval`で永遠に情報を取得し続けることになります。\n\n```shell\n$ sar -r 2\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n11:10:56 PM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n11:10:58 PM    351584    663840     65.38     50368    456536    287232      9.23    394124    182816         0\n11:11:00 PM    351584    663840     65.38     50368    456536    287232      9.23    394124    182816         0\n11:11:02 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n11:11:04 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n11:11:06 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n11:11:08 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n11:11:10 PM    351584    663840     65.38     50368    456536    287232      9.23    394128    182816         0\n...\n```\n\n# 見るリソースを指定するオプション\n\nここまでで、`sar`コマンドを使って「いつの」情報を見るかの指定方法についてはだいたいわかったので、次に「どの」情報を見るかの指定方法を見ていきます。最初に述べたように、どのリソースの情報を見るかはオプションで指定します。オプションは大量にある（`man`で見てくれ）のですが、その中でも利用頻度が高そうなオプションについて示します。また、各オプションに対して出力される情報の中でも特に有用と思われるものについてのみ内容を示しています。\n\n## CPU\n\n#### CPU使用率（`sar -P ALL`）\n\n```shell\n$ sar -P ALL 1\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n01:17:35 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle\n01:17:36 AM     all      0.00      0.00      0.00      0.00      0.00    100.00\n01:17:36 AM       0      0.00      0.00      0.00      0.00      0.00    100.00\n01:17:36 AM       1      0.00      0.00      0.00      0.00      0.00    100.00\n\n01:17:36 AM     CPU     %user     %nice   %system   %iowait    %steal     %idle\n01:17:37 AM     all      0.00      0.00      0.00      0.00      0.00    100.00\n01:17:37 AM       0      0.00      0.00      0.00      0.00      0.00    100.00\n01:17:37 AM       1      0.00      0.00      0.00      0.00      0.00    100.00\n...\n```\n- `%user`：CPUがユーザモードにあった時間の割合\n- `%system`：CPUがカーネルモードにあった時間の割合\n- `%iowait`：CPUがIO待ちをしていた時間の割合\n- `%idle`：CPUがアイドル状態にあった時間の割合\n\nマルチコアの場合、上記の結果ようにCPUごとの使用率が見られます。当然ですが、全てのカラムの値を足すと100%になります。`%idle`の値が小さいとCPUの使用率が高いということになので、CPUがパフォーマンスのボトルネックになっている可能性があります。\n\n#### ランキュー/load average（`sar -q`）\n\n```shell\n$ sar -q 1\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n01:17:09 AM   runq-sz  plist-sz   ldavg-1   ldavg-5  ldavg-15   blocked\n01:17:10 AM         1       102      0.00      0.01      0.03         0\n01:17:11 AM         1       102      0.00      0.01      0.03         0\n...\n```\n- `runq-sz`：ランキューにあるタスク数\n- `ldavg-\u003cn\u003e`：最近n分間のロードアベレージ\n\nランキューにあるタスク数は、「CPUが現在同時に実行しているタスク数」を表しています。一般に、ランキューにあるタスク数がCPUの数を超えると、CPUの数が足りておらずパフォーマンスが落ちている可能性があると言われています。ランキューのタスク数は計算機のパフォーマンスがおかしい時に必ず見るべき重要な指標です。ロードアベレージはランキューのタスク数の時間平均で、こちらも同様に重要です。過去１分間、５分間、１５分間の値が表示されているので、大まかに、負荷が上がってきているのか落ち着いてきているのか把握することができます。\n\nランキュー/ロードアベレージについてのもっとちゃんとした説明は世の中にたくさんあると思いますが、自分は[サーバ/インフラを支える技術](https://www.amazon.co.jp/24%E6%99%82%E9%96%93365%E6%97%A5-%E3%82%A4%E3%83%B3%E3%83%95%E3%83%A9%E3%82%92%E6%94%AF%E3%81%88%E3%82%8B%E6%8A%80%E8%A1%93-%E2%80%BE%E3%82%B9%E3%82%B1%E3%83%BC%E3%83%A9%E3%83%93%E3%83%AA%E3%83%86%E3%82%A3%E3%80%81%E3%83%8F%E3%82%A4%E3%83%91%E3%83%95%E3%82%A9%E3%83%BC%E3%83%9E%E3%83%B3%E3%82%B9%E3%80%81%E7%9C%81%E5%8A%9B%E9%81%8B%E7%94%A8-PRESS-plus%E3%82%B7%E3%83%AA%E3%83%BC%E3%82%BA/dp/4774135666)の4.1節が非常にわかりやすかったのでおすすめです。\n\n## メモリ\n\n#### メモリ使用率（`sar -r`）\n\n```shell\n$ sar -r 1\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n01:16:48 AM kbmemfree kbmemused  %memused kbbuffers  kbcached  kbcommit   %commit  kbactive   kbinact   kbdirty\n01:16:49 AM    416672    598752     58.97     25092    434648    274480      8.82    373028    156644         0\n01:16:50 AM    416672    598752     58.97     25092    434648    274480      8.82    373028    156644         0\n...\n```\n- `kbmemfree`：空きメモリのkB数\n- `kbmemused`：使用中メモリのkB数\n- `%memused`：メモリ使用率\n- `kbbuffers`：バッファとして使われているメモリのkB数\n- `kbcached`：ページキャッシュとして使われているメモリのkB数\n\nメモリが足りなくなると、メモリの一部をストレージに退避させるスワッピングが発生しパフォーマンスが大きく劣化することがあるので注意。ただし、`kbbuffers`と`kbcached`はカーネルがいつでも開放することができるキャッシュなので、たとえメモリ使用率が高かったとしても、この２つの値が大きい場合には問題にはなりません。ページキャッシュやスワップについてのわかりやすい記事として、例えば [いまさら聞けないLinuxとメモリの基礎＆vmstatの詳しい使い方](https://qiita.com/kunihirotanaka/items/70d43d48757aea79de2d) を読むと良いでしょう。\n\n#### スワッピング（`sar -S`、`sar -W`）\n\n```shell\n$ sar -S 1\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n01:16:32 AM kbswpfree kbswpused  %swpused  kbswpcad   %swpcad\n01:16:33 AM   2097148         0      0.00         0      0.00\n01:16:34 AM   2097148         0      0.00         0      0.00\n...\n```\n- `kbswpfree`：空いているスワップ領域のkB数\n- `kbswpused`：使用中のスワップ領域のkB数\n- `%swpused`：スワップ領域の使用率\n\n`kbswapused`が0よりも大きい値ならばスワッピングが発生していることになります。\n\n```shell\n$ sar -W 1\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n01:16:14 AM  pswpin/s pswpout/s\n01:16:15 AM      0.00      0.00\n01:16:16 AM      0.00      0.00\n...\n```\n- `pswpin/s`：１秒間あたりのスワップインされたページ数\n- `pswpout/s`：１秒間あたりのスワップアウトされたページ数\n\n特に、スワップアウトが連続で起きている場合はパフォーマンスに影響を与えている可能性が高いです。\n\n## ディスクIO\n\n#### 読み込み/書き込み量（`sar -d -p`）\n\n```shell\n$ sar -d -p 1\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n01:15:54 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util\n01:15:55 AM       vda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n01:15:55 AM       sr1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n\n01:15:55 AM       DEV       tps  rd_sec/s  wr_sec/s  avgrq-sz  avgqu-sz     await     svctm     %util\n01:15:56 AM       vda      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n01:15:56 AM       sr1      0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n...\n```\n- `tps`：１秒間あたりのI/O転送回数\n- `td_sec/s`：１秒間あたりに読み込みを行ったセクター数\n- `wr_sec/s`：１秒間あたりに書き込みを行ったセクター数\n- `await`：I/O応答時間の平均\n- `%util`：ディスクの使用率（I/O処理をしていてビジーだった時間の割合）\n\n`%util`の値が大きい場合はIOがボトルネックになっている可能性があります。また、`await`はアプリケーションのパフォーマンスに直接的に影響する値なので重要です。\n\n## ネットワーク\n\n#### 受信/送信パケット数（`sar -n DEV`）\n\n```shell\n$ sar -n DEV 1\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n01:15:29 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s\n01:15:30 AM      eth0     19.00      0.00      2.27      0.00      0.00      0.00      0.00\n01:15:30 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n\n01:15:30 AM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s\n01:15:31 AM      eth0     23.00      1.00      2.39      0.18      0.00      0.00      0.00\n01:15:31 AM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00\n...\n```\n- `rxpck/s`：１秒間あたりの受信パケット数\n- `txpck/s`：１秒間あたりの送信パケット数\n- `rxkB/s`：１秒間あたりの受信kB数\n- `txkB/s`：１秒間あたりの送信kB数\n\n#### TCP接続数（`sar -n TCP`）\n\n```shell\n$ sar -n TCP 1\nLinux 3.10.0-862.2.3.el7.x86_64 (118-27-1-88) \t10/01/2018 \t_x86_64_\t(2 CPU)\n\n01:14:59 AM  active/s passive/s    iseg/s    oseg/s\n01:15:00 AM      0.00      0.00      2.00      0.00\n01:15:01 AM      0.00      0.00      1.00      1.00\n...\n```\n- `active/s`：１秒間あたりのアクティブなTCP新規接続数\n- `passive/s`：１秒間あたりのパッシブなTCP新規接続数\n- `iseg/s`：１秒間あたりの受信セグメント数\n- `oseg/s`：１秒間あたりの送信セグメント数\n\n# まとめ\n\n- `sar`を使うと、オプションを指定することによってCPUやメモリ、IOやネットワークなど計算機のパフォーマンスに関わる様々なリソースの情報を見ることができる。\n- 自動で定期的に`sar`の情報が取得されているので、過去に遡って計算機の状況を確認することができる。一方で、リアルタイムで自由に間隔を指定して情報を取得することもできる\n","coediting":false,"comments_count":0,"created_at":"2018-10-09T22:32:00+09:00","group":null,"id":"956ac41c4cf6cf85ae12","likes_count":6,"private":false,"reactions_count":0,"tags":[{"name":"Linux","versions":[]},{"name":"Linuxコマンド","versions":[]}],"title":"sarコマンドの使い方","updated_at":"2018-10-09T22:32:00+09:00","url":"https://qiita.com/muiscript/items/956ac41c4cf6cf85ae12","user":{"description":"Go / Typescript / Ruby / shell script","facebook_id":"","followees_count":5,"followers_count":12,"github_login_name":"muiscript","id":"muiscript","items_count":14,"linkedin_id":"","location":"","name":"","organization":"","permanent_id":159260,"profile_image_url":"https://qiita-image-store.s3.amazonaws.com/0/159260/profile-images/1539056316","team_only":false,"twitter_screen_name":null,"website_url":""},"page_views_count":null}]